# 클래스, 객체, 인터페이스
1. 클래스와 인터페이스
2. 뻔하지 않은 생성자와 프로퍼티
3. 데이터 클래스
4. 클래스 위임
5. object 키워드 사용

코틀린의 클래스와 인터페이스는 자바 클래스, 인터페이스와는 약간 다르다. 

자바와 달리 코틀린 선언은 기본적으로  final이며 public이다.:heart_eyes:

코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다.:grey_question:

짧은 주 생성자 구문으로도 거의 모든 경우를 잘 처리할 수 있다.

하지만, 복잡한 초기화 로직을 수행하는 경우를 대비한 완전한 문법도 있다.:grey_question:

프로퍼티도 마찬가지이다. 간결한 프로퍼티 구문으로도 충분히 제 몫을 하지만, 필요하면 접근자를 직접 정의할 수 있다.

코틀린 컴파일러는 번잡스러움을 피하기 위해 유용한 메소드를 자동으로 만들어준다.

클래스를 data로 선언하면 컴파일러가 일부 표준 메소드를 생성해준다.:heart_eyes:

그리고 코틀린 언어가 제공하는 위임을 사용하면 위임을 처리하기 위한 준비 메소드를 직접 작성할 필요가 없다.:grey_question:

또한 클래스와 인스턴스를 동시에 선언하면서 만들 떄 쓰는 object 키워드에 대해 설명한다.

싱글턴 클래스, 동반 객체, 객체 식(자바의 무명객체에 해당)을 표현할 때 object 키워드를 쓴다.

## 1. 클래스 계층 정의
- 코틀린에서 클래스 계층을 정의하는 방식과 자바 방식을 비교
- 코틀린의 가시성과 접근 변경자에 대해 살펴본다.
- 코틀린의 sealed 변경자에 대해 설명한다.

### 1). 코틀린 인터페이스 
인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.

자바와 마찬가지로 상속은 단일, 인터페이스는 무제한이다.

자바의 @Override 애노테이션과 비슷한 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드한다는 표시다.

하지만, 코틀린에서는 자바와 달리 override 변경자를 꼭 사용해야 한다.

그래서 상위 클래스에 있는 메소드와 시그니처가 같은 메소드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 안 되기 때문에 override를 붙이거나 메소드 이름을 바꿔야만 한다.

반대로 코틀린에서는 인터페이스의 디폴트 메소드를 꾸밀 필요가 없다.
```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!")
}
```

한 클래스에서 같은 이름의 디폴트 메소드를 갖은 두 인터페이스를 함께 구현하면 어떤 일이 발생할까?

-> 컴파일 오류가 발생한다.

코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

```kotlin
class Button : Clickable, Focusable {
    override fun click() {
    }

    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

자바에서는 Clickable.super.showOff() 처럼 super 앞에 기반 타입을 적지만,

코틀린에서는 super<Clickable>.showOff() 처럼 꺾쇠 괄호 안에 기반 타입 이름을 지정한다.

상속한 구현 중 하나만 호출해도 된다면

```kotlin
class Button : Clickable, Focusable {
    override fun click() {
    }

    override fun showOff() = super<Clickable>.showOff()
}
```

이렇게 표현할 수 있다.



### 2). open, final, abstract 변경자: 기본적으로 final
취약한 기반 클래스라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다.

[Effective Java]에서는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라는 조언을 한다.

코틀린은 클래스와 메소드는 기본적으로 final이다.

어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다.

더불어 오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙인다.

기반 클래스나 인터페이스 멤버를 오버라이드하는 경우 그 메소드는 기본적으로 열려있다.

오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final을 명시해야한다.

- [예제보러가기](./RichButton.kt)

- 열린 클래스와 스마트 캐스트
클래스의 기본적인 상속 가능 상태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.
  
final클래스의 프로퍼티는 기본적으로 finald이기 때문에 따로 고민할 필요 없이 대부분의 프로퍼티를 스마트 캐스트에 활용할 수 있다.

자바처럼 코틀린에서도 클래스를 abstract로 선언할 수 있다.

추상 멤버는 오버라이드해야만 하는 게 보통이다.

따라서 추상 멤버 앞에 open 변경자를 명시할 필요가 없다.

- 클래스 내에서 상속 제어 변경자의 의미
1. final : 오버라이드할 수 없음
2. open : 오버라이드할 수 있음
3. abstract : 반드시 오버라이드해야 함
4. override : 상위 클래스나 상위 인스턴스 멤버를 오버라이드하는 중
