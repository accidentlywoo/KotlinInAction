# 클래스, 객체, 인터페이스
1. 클래스와 인터페이스
2. 뻔하지 않은 생성자와 프로퍼티
3. 데이터 클래스
4. 클래스 위임
5. object 키워드 사용

코틀린의 클래스와 인터페이스는 자바 클래스, 인터페이스와는 약간 다르다. 

자바와 달리 코틀린 선언은 기본적으로  final이며 public이다.:heart_eyes:

코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다.:grey_question:

짧은 주 생성자 구문으로도 거의 모든 경우를 잘 처리할 수 있다.

하지만, 복잡한 초기화 로직을 수행하는 경우를 대비한 완전한 문법도 있다.:grey_question:

프로퍼티도 마찬가지이다. 간결한 프로퍼티 구문으로도 충분히 제 몫을 하지만, 필요하면 접근자를 직접 정의할 수 있다.

코틀린 컴파일러는 번잡스러움을 피하기 위해 유용한 메소드를 자동으로 만들어준다.

클래스를 data로 선언하면 컴파일러가 일부 표준 메소드를 생성해준다.:heart_eyes:

그리고 코틀린 언어가 제공하는 위임을 사용하면 위임을 처리하기 위한 준비 메소드를 직접 작성할 필요가 없다.:grey_question:

또한 클래스와 인스턴스를 동시에 선언하면서 만들 떄 쓰는 object 키워드에 대해 설명한다.

싱글턴 클래스, 동반 객체, 객체 식(자바의 무명객체에 해당)을 표현할 때 object 키워드를 쓴다.

## 1. 클래스 계층 정의
- 코틀린에서 클래스 계층을 정의하는 방식과 자바 방식을 비교
- 코틀린의 가시성과 접근 변경자에 대해 살펴본다.
- 코틀린의 sealed 변경자에 대해 설명한다.

### 1). 코틀린 인터페이스 
인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.

자바와 마찬가지로 상속은 단일, 인터페이스는 무제한이다.

자바의 @Override 애노테이션과 비슷한 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드한다는 표시다.

하지만, 코틀린에서는 자바와 달리 override 변경자를 꼭 사용해야 한다.

그래서 상위 클래스에 있는 메소드와 시그니처가 같은 메소드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 안 되기 때문에 override를 붙이거나 메소드 이름을 바꿔야만 한다.

반대로 코틀린에서는 인터페이스의 디폴트 메소드를 꾸밀 필요가 없다.
```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!")
}
```

한 클래스에서 같은 이름의 디폴트 메소드를 갖은 두 인터페이스를 함께 구현하면 어떤 일이 발생할까?

-> 컴파일 오류가 발생한다.

코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

```kotlin
class Button : Clickable, Focusable {
    override fun click() {
    }

    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

자바에서는 Clickable.super.showOff() 처럼 super 앞에 기반 타입을 적지만,

코틀린에서는 super<Clickable>.showOff() 처럼 꺾쇠 괄호 안에 기반 타입 이름을 지정한다.

상속한 구현 중 하나만 호출해도 된다면

```kotlin
class Button : Clickable, Focusable {
    override fun click() {
    }

    override fun showOff() = super<Clickable>.showOff()
}
```

이렇게 표현할 수 있다.



### 2). open, final, abstract 변경자: 기본적으로 final
취약한 기반 클래스라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다.

[Effective Java]에서는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라는 조언을 한다.

코틀린은 클래스와 메소드는 기본적으로 final이다.

어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다.

더불어 오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙인다.

기반 클래스나 인터페이스 멤버를 오버라이드하는 경우 그 메소드는 기본적으로 열려있다.

오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final을 명시해야한다.

- [예제보러가기](./RichButton.kt)

- 열린 클래스와 스마트 캐스트
클래스의 기본적인 상속 가능 상태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.
  
final클래스의 프로퍼티는 기본적으로 finald이기 때문에 따로 고민할 필요 없이 대부분의 프로퍼티를 스마트 캐스트에 활용할 수 있다.

자바처럼 코틀린에서도 클래스를 abstract로 선언할 수 있다.

추상 멤버는 오버라이드해야만 하는 게 보통이다.

따라서 추상 멤버 앞에 open 변경자를 명시할 필요가 없다.

- 클래스 내에서 상속 제어 변경자의 의미
1. final : 오버라이드할 수 없음
2. open : 오버라이드할 수 있음
3. abstract : 반드시 오버라이드해야 함
4. override : 상위 클래스나 상위 인스턴스 멤버를 오버라이드하는 중

### 3).가시성 변경자: 기본적으로 공개
가시성 변경자는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.

코틀린의 기본 가시성은 자바와 다르다.

아무 변경자도 없는 경우 선언은 모두 공개(public)된다.

자바의 기본 가시성인 패키지 전용(package-private)은 코틀린에 없다.

코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다.

그래서 패키지를 가시성에 제어에 사용하지 않는다.

패키지 전용 가시성에 대한 대안으로 코틀린에는 internal이라는 새로운 가시성 변경자를 도입했다.

internal은 모듈 내부에서만 볼 수 있음이라는 뜻이다.

모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.

모듈 내부 가시성은 개발자의 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.

자바에서는 패키지가 같은 클래스를 선언하기만 하면 어떤 프로젝트의 외부에있는 코드라도 패키지 내부에 있는 패키지 전용 선언에 쉽게 접근할 수 있다.

그래서 모듈의 캡슐화가 쉽게 깨진다.

또 다른 차이는 코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다는 점이다.

그런 최상위 선언에는 클래스, 함수, 프로퍼티 등이 포함된다.

비공개 가시성인 최상위 선언은 그 선언이 들어있는 파일 내부에서만 사용할 수 있다.

- 코틀린 가시성 변경자
1. public(기본 가시성) : 모든 곳
2. internal : 같은 모듈 안에서만 볼 수 있다.
3. protected : 하위 클래스 안에서만 볼 수 있다. (최상위 선언에 적용할 수 없음)
4. private : 같은 클래스 안에서만 볼 수 있다.

- [예제보러 가기](./TalkativeButton.kt)

protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.

코틀린과 자바 가시성 규칙의 또 다른 차이는 코틀리엔서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다는 점이다.

