# 클래스, 객체, 인터페이스
1. 클래스와 인터페이스
2. 뻔하지 않은 생성자와 프로퍼티
3. 데이터 클래스
4. 클래스 위임
5. object 키워드 사용

코틀린의 클래스와 인터페이스는 자바 클래스, 인터페이스와는 약간 다르다. 

자바와 달리 코틀린 선언은 기본적으로  final이며 public이다.:heart_eyes:

코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다.:grey_question:

짧은 주 생성자 구문으로도 거의 모든 경우를 잘 처리할 수 있다.

하지만, 복잡한 초기화 로직을 수행하는 경우를 대비한 완전한 문법도 있다.:grey_question:

프로퍼티도 마찬가지이다. 간결한 프로퍼티 구문으로도 충분히 제 몫을 하지만, 필요하면 접근자를 직접 정의할 수 있다.

코틀린 컴파일러는 번잡스러움을 피하기 위해 유용한 메소드를 자동으로 만들어준다.

클래스를 data로 선언하면 컴파일러가 일부 표준 메소드를 생성해준다.:heart_eyes:

그리고 코틀린 언어가 제공하는 위임을 사용하면 위임을 처리하기 위한 준비 메소드를 직접 작성할 필요가 없다.:grey_question:

또한 클래스와 인스턴스를 동시에 선언하면서 만들 떄 쓰는 object 키워드에 대해 설명한다.

싱글턴 클래스, 동반 객체, 객체 식(자바의 무명객체에 해당)을 표현할 때 object 키워드를 쓴다.

## 1. 클래스 계층 정의
- 코틀린에서 클래스 계층을 정의하는 방식과 자바 방식을 비교
- 코틀린의 가시성과 접근 변경자에 대해 살펴본다.
- 코틀린의 sealed 변경자에 대해 설명한다.

### 1). 코틀린 인터페이스 
인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.

자바와 마찬가지로 상속은 단일, 인터페이스는 무제한이다.

자바의 @Override 애노테이션과 비슷한 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드한다는 표시다.

하지만, 코틀린에서는 자바와 달리 override 변경자를 꼭 사용해야 한다.

그래서 상위 클래스에 있는 메소드와 시그니처가 같은 메소드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 안 되기 때문에 override를 붙이거나 메소드 이름을 바꿔야만 한다.

반대로 코틀린에서는 인터페이스의 디폴트 메소드를 꾸밀 필요가 없다.
```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!")
}
```

한 클래스에서 같은 이름의 디폴트 메소드를 갖은 두 인터페이스를 함께 구현하면 어떤 일이 발생할까?

-> 컴파일 오류가 발생한다.

코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

```kotlin
class Button : Clickable, Focusable {
    override fun click() {
    }

    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

자바에서는 Clickable.super.showOff() 처럼 super 앞에 기반 타입을 적지만,

코틀린에서는 super<Clickable>.showOff() 처럼 꺾쇠 괄호 안에 기반 타입 이름을 지정한다.

상속한 구현 중 하나만 호출해도 된다면

```kotlin
class Button : Clickable, Focusable {
    override fun click() {
    }

    override fun showOff() = super<Clickable>.showOff()
}
```

이렇게 표현할 수 있다.



### 2). open, final, abstract 변경자: 기본적으로 final
취약한 기반 클래스라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다.

[Effective Java]에서는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라는 조언을 한다.

코틀린은 클래스와 메소드는 기본적으로 final이다.

어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다.

더불어 오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙인다.

기반 클래스나 인터페이스 멤버를 오버라이드하는 경우 그 메소드는 기본적으로 열려있다.

오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final을 명시해야한다.

- [예제보러가기](./RichButton.kt)

- 열린 클래스와 스마트 캐스트
클래스의 기본적인 상속 가능 상태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.
  
final클래스의 프로퍼티는 기본적으로 finald이기 때문에 따로 고민할 필요 없이 대부분의 프로퍼티를 스마트 캐스트에 활용할 수 있다.

자바처럼 코틀린에서도 클래스를 abstract로 선언할 수 있다.

추상 멤버는 오버라이드해야만 하는 게 보통이다.

따라서 추상 멤버 앞에 open 변경자를 명시할 필요가 없다.

- 클래스 내에서 상속 제어 변경자의 의미
1. final : 오버라이드할 수 없음
2. open : 오버라이드할 수 있음
3. abstract : 반드시 오버라이드해야 함
4. override : 상위 클래스나 상위 인스턴스 멤버를 오버라이드하는 중

### 3).가시성 변경자: 기본적으로 공개
가시성 변경자는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.

코틀린의 기본 가시성은 자바와 다르다.

아무 변경자도 없는 경우 선언은 모두 공개(public)된다.

자바의 기본 가시성인 패키지 전용(package-private)은 코틀린에 없다.

코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다.

그래서 패키지를 가시성에 제어에 사용하지 않는다.

패키지 전용 가시성에 대한 대안으로 코틀린에는 internal이라는 새로운 가시성 변경자를 도입했다.

internal은 모듈 내부에서만 볼 수 있음이라는 뜻이다.

모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.

모듈 내부 가시성은 개발자의 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.

자바에서는 패키지가 같은 클래스를 선언하기만 하면 어떤 프로젝트의 외부에있는 코드라도 패키지 내부에 있는 패키지 전용 선언에 쉽게 접근할 수 있다.

그래서 모듈의 캡슐화가 쉽게 깨진다.

또 다른 차이는 코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다는 점이다.

그런 최상위 선언에는 클래스, 함수, 프로퍼티 등이 포함된다.

비공개 가시성인 최상위 선언은 그 선언이 들어있는 파일 내부에서만 사용할 수 있다.

- 코틀린 가시성 변경자
1. public(기본 가시성) : 모든 곳
2. internal : 같은 모듈 안에서만 볼 수 있다.
3. protected : 하위 클래스 안에서만 볼 수 있다. (최상위 선언에 적용할 수 없음)
4. private : 같은 클래스 안에서만 볼 수 있다.

- [예제보러 가기](./TalkativeButton.kt)

protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.

코틀린과 자바 가시성 규칙의 또 다른 차이는 코틀리엔서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다는 점이다.



### 4). 내부 클래스와 중첩된 클래스 : 기본적으로 중첩 클래스
중첩클래스에서 자바와 차이는 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 함 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다는 점이다.

- [자바 예제 보러가기](./ButtonJava.java)

자바는 클래스 안에 정의한 클래스는 자동으로 내부 클래스가 된다.

따라서 내부 클래스는 직렬화할 수 없다.

이 문제를 해결하려면 내부 클래스는 static 클래스로 선언해야 한다.

자바에서 중첩 클래스를 static으로 선언하면 그 클래스를 둘러싼 바깥쪽 클래스에 대한 묵시적인 참조가 사라진다.

코틀린에서 중첩된 클래스가 기본적으로 동작하는 방식은 방금 설명한 자바의 동작과 정반대다.

- [코틀린 예제 보러가기](./ButtonKotlin.kt)

코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다.

이를 내부 클래스로 만들고 싶다면 inner 변경자를 붙여야 한다.

코틀린에서 바깥쪽 클래스의 인스턴스를 가리키는 참조를 표가하는 방법도 자바와 다르다.

내부 클래스 Inner 안에서 바깥쪽 클래스 Outer의 참조에 접근하려면 this@Outer라고 써야한다.

- [코틀린 내부클래스 예제 보러가기](./Outer.kt)

### 5). 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한
when식에서 타입 검사를 할 때, 디폴트 분기인 else분기는 덕붙이게 강제한다.

```kotlin
interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr

fun eval(e: Expr) : Int =
	when(e) {
		is Num -> e.value
		is Sum -> eval(e.right) + eval(e.left)
		else ->
			throw IllegalArgumentException("Unknown expression")
	}

```

항상 디폴트 분기를 추가하는 게 편하지는 않다. 

실수로 새로운 클래스 처리를 잊어버렸더라도 디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수 있다.

코틀린은 이런 문제에 대한 해법으로 sealed클래스를 제공한다.

````kotlin
sealed class Expr{
	class Num(val value: Int) : Expr()
	class Sum(val left: Expr, val right: Expr) : Expr()
}

fun eval(e: Expr) : Int =
	when(e) {
		is Expr.Num -> e.value
		is Expr.Sum -> eval(e.right) + eval(e.left)
	}
````

when 식에서 sealed 클래스의 모든 하위 클래스를 처리한다면 디폴트 분기(else)가 필요 없다.

sealed로 표시된 클래스는 자동으로 open이다.

```kotlin
class Num(val value: Int) : Expr()
```
이 선언의 맨 마지막의 Expr()는 코틀린의 클래스 초기화에 대해 다루는 다음절에서 설명



## 2. 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언
코틀린은 주 생성자와 부 생성자를 구분한다.

또한 코틀린에서는 초기화 블록을 통해 초기화 로직을 추가할 수 있다.

### 1). 클래스 초기화: 주 생성자와 초기화 블록
```kotlin
class User(val nickname: String)
```
class 이름뒤에 괄호로 둘러싸인 코드를 주 생성자라고 부른다.

이 선언과 똑같이 동작하는 명시적인 선언을 보자

```kotlin
class User constructor(_nickname: String) {
	val nickname: String
	
	init {
		nickname = _nickname
    }
}
```
위 코드는 constructor와 init이라는 새로운 키워드를 볼 수 있다.

constructor 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용한다.

init 키어드는 초기화 블록을 시작한다.

초기화 블록은 주 생성자와 함께 사용된다.

주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록이 필요하다.

```kotlin
class User(_nickname: String) {
	val _nickname = _nickname
}
```
주 생성자 앞에 별다른 애노테이션이나 가시성 변경자가 없다면 위 코드처럼  constructor를 생략해도 된다.

위 코드에서 주 생성자 파라미터 이름앞에 val을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.

```kotlin
class User(val nickname: String)
```

위 세가지 User 선언은 모두 같다.

가장 간단한 마지막 선언 :heart_eyes:

클래스의 인스턴스를 만들려면 new 키워드 없이 생성자를 직접 호출하면 된다.

모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다.

그렇게 자동으로 만들어진 파라미터 없는 생성자는 디폴트 값을 사용해 클래스를 초기화한다.

의존관계 주입(DI) 프레임워크 등 자바 라이브러리 중에는 파라미터가 없는 생성자를 통해 객체를 생성해야만 라이브러리 사용이 가능한 경우가 있는데,

코틀린이 제공하는 파라미터 없는 생성자는 그런 라이브러리와의 통합을 쉽게 해준다.

클래스에 기반 클래스가 있다면 주 생성자에서 기반 클래스의 생성자를 호출해야 할 필요가 있다.

기반 클래스를 초기화하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다

```kotlin
open class User(val nickname: String) { ... }
class TwitterUser(nickname: String) : User(nickname) { ... }
```

클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다.

```kotlin
open class Button
```
-> 인자가 없는 디폴트 생성자가 만들어진다.

Button의 생성자는 아무 인자도 받지 않지만, Button 클래스를 상속한 하위 클래스는 반드시 Button클래스의 생성자를 호출해야한다.

```kotlin
class RadioButton: Button()
```

인터페이스는 생성자가 없기 때문에 어떤 클래스가 인터페이스를 구현하는 경우 그 클래스의 상위 클래스 목록에 있는 인터페이스 이름 뒤에는 아무 괄호도 없다.

클래스 정의에 있는 상위 클래스 목록에 있는 인터페이스 목록에서 이름 뒤에 괄호가 붙었는지 살펴보면 쉽게 기반 클래스와 인터페이스를 구별할 수 있다.

어떤 클래스를 클래스 외부에서 인스턴스화하지 못하게 막고 싶다면 모든 생성자를 private으로 만들면 된다.

```kotlin
class Secretive private constructor() {}
```

Secretive 클래스 안에는 주 생성자밖에 없고, 그 주 생성자는 비공개이므로 외부에서는 Secretive를 인스턴스화할 수 없다.

나중에 동반 객체에 대해 설명하면서 동반 객체 안에서 이런 비공개 생성자를 호출하면 좋은 이유에 대해 알아본다.

대부분 이런 간단한 주 생성자 구문만으로 충분하다. 하지만 다양한 생성자를 정의하는 방법도 알아보자!



