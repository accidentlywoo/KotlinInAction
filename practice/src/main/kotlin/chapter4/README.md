# 클래스, 객체, 인터페이스
1. 클래스와 인터페이스
2. 뻔하지 않은 생성자와 프로퍼티
3. 데이터 클래스
4. 클래스 위임
5. object 키워드 사용

코틀린의 클래스와 인터페이스는 자바 클래스, 인터페이스와는 약간 다르다. 

자바와 달리 코틀린 선언은 기본적으로  final이며 public이다.:heart_eyes:

코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다.:grey_question:

짧은 주 생성자 구문으로도 거의 모든 경우를 잘 처리할 수 있다.

하지만, 복잡한 초기화 로직을 수행하는 경우를 대비한 완전한 문법도 있다.:grey_question:

프로퍼티도 마찬가지이다. 간결한 프로퍼티 구문으로도 충분히 제 몫을 하지만, 필요하면 접근자를 직접 정의할 수 있다.

코틀린 컴파일러는 번잡스러움을 피하기 위해 유용한 메소드를 자동으로 만들어준다.

클래스를 data로 선언하면 컴파일러가 일부 표준 메소드를 생성해준다.:heart_eyes:

그리고 코틀린 언어가 제공하는 위임을 사용하면 위임을 처리하기 위한 준비 메소드를 직접 작성할 필요가 없다.:grey_question:

또한 클래스와 인스턴스를 동시에 선언하면서 만들 떄 쓰는 object 키워드에 대해 설명한다.

싱글턴 클래스, 동반 객체, 객체 식(자바의 무명객체에 해당)을 표현할 때 object 키워드를 쓴다.

## 1. 클래스 계층 정의
- 코틀린에서 클래스 계층을 정의하는 방식과 자바 방식을 비교
- 코틀린의 가시성과 접근 변경자에 대해 살펴본다.
- 코틀린의 sealed 변경자에 대해 설명한다.

### 1). 코틀린 인터페이스 
인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

코틀린에서는 클래스 이름 뒤에 콜론(:)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.

자바와 마찬가지로 상속은 단일, 인터페이스는 무제한이다.

자바의 @Override 애노테이션과 비슷한 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드한다는 표시다.

하지만, 코틀린에서는 자바와 달리 override 변경자를 꼭 사용해야 한다.

그래서 상위 클래스에 있는 메소드와 시그니처가 같은 메소드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 안 되기 때문에 override를 붙이거나 메소드 이름을 바꿔야만 한다.

반대로 코틀린에서는 인터페이스의 디폴트 메소드를 꾸밀 필요가 없다.
```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!")
}
```

한 클래스에서 같은 이름의 디폴트 메소드를 갖은 두 인터페이스를 함께 구현하면 어떤 일이 발생할까?

-> 컴파일 오류가 발생한다.

코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

```kotlin
class Button : Clickable, Focusable {
    override fun click() {
    }

    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

자바에서는 Clickable.super.showOff() 처럼 super 앞에 기반 타입을 적지만,

코틀린에서는 super<Clickable>.showOff() 처럼 꺾쇠 괄호 안에 기반 타입 이름을 지정한다.

상속한 구현 중 하나만 호출해도 된다면

```kotlin
class Button : Clickable, Focusable {
    override fun click() {
    }

    override fun showOff() = super<Clickable>.showOff()
}
```

이렇게 표현할 수 있다.