# 코틀린 타입 시스템

1. 널 가능성
2. 코틀린 원시 타입
3. 컬렉션과 배열

코틀린의 타입 시스템은 코드의 가독성을 향상시키는 데 도움이 되는 몇 가지 특성을 제공한다.

그 특성으로 널이 될 수 있는 타입과 읽기 전용 컬렉션이 있다.

또한 코틀린은 자바 타입 시스템에서 불필요하거나 문제가 되던 부분을 제거했다.

배열 지원이 그런 예에 속한다.

## 1. 널 가능성
널 가능성은 NPE(NullPointerException)를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.

코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 이 문제를 가능한 컴파일 시점으로 옮가는 것이다.

널이 될 수 있는지 여부를 타입 시트메에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

### 1.1 널이 될 수 있는 타입
코틀린과 자바의 첫 번째이자 가장 중요한 차이는 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점이다.

어떤 변수가 널이 될 수 있다면 그 변수에 대해(그 변수를 수신 객체로) 메소드를 호출하면 NPE이 발생할 수 있으므로 안전하지 않다.

코틀린은 그런 메소드 호출을 금지함으로써 많은 오류를 방지한다.

```java
int stringLength(String string) {
    return string.length()
}
```
위 메소드는 안전한가? 이 함수에 null을 넘기면 NPE가 발생한다.

```kotlin
fun stringLength(string: String) = string.length
```
코틀린에서는 stringLength함수에 null이거나, null이 될 수 있는 인자를 넘기는 것은 금지되며, 혹시 그런 값을 넘기면 컴파일 시 오류가 발생한다.

따라서, stringLength함수가 결코 실행 시점에 NPE을 발생시키지 않으리라 장담할 수 있다.

 이 함수가 널과 문자열을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표를 명시해야한다.

```kotlin
fun stringLength(string: String?) = string.length
// ERROR: only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String>
```

널이 됳 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.

또, 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다
```kotlin
val x: String? = null
val y: String = x
// ERROR: Type mismatch: inferred type is String? but string was expected
```
널 가능성을 다루기 위해 사용할 수 있는 도구가 of 검사뿐이라면 코드가 번잡해지는 일을 피할 수 없을 것이다.

다행히 코틀린은 널이 될 수 있는 값을 다룰 때 도움이 되는 여러 도구를 제공한다.

### 1.2 타입의 의미
위키피디아에서 타입은 "타입은 분류(classification)로 .. 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다."

자바의 타입 시스템은 null이 들어있는 경우에는 사용할 수 있는 연산이 많지 않다.

이는 자바의 타입 시스템이 널을 제대로 다루지 못한다는 뜻이다.

변수에 선언된 타입이 있지만 널 여부를 추가로 검사하기 전에는 그 변수에 대한 어떤 연산을 수행할 수 있을지 알 수 없다.

프로그램을 작성하면서 프로그램의 데이터 흐름속에서 특정 위치에 특정 변수가 절대로 널일 수 없다는 사실을 확인하고 이런 검사를 생략하는 경우가 자주 있다.

하지만 그 생각이 틀리면 실행 시점에서 프로그램이 NPE 예외를 발생시키며 오류로 중단된다.

 코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.

널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고, 

실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다. 따라서 그런 연산을 아예 금지시킬 수 있다.

> 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.
>
> 모든 검사는 컴파일 시점에 수향된다. 
> 
> 따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다.

### 1.3 안전한 호출 연산자 ?.
?. 은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.

예를 들어 ```s?.toUpperCase()```는 훨씬 더 복잡한 ```if (s != null) s.toUppserCase() else null ```과 같다

안전한 호출의 결과 타입도 널이 될 수 있는 타입이라는 사실에 위의 하자.

```kotlin
fun printAllCaps(s: String?) {
	val allCaps: String? = s?.toUpperCase()
    println(allCaps)
}

// >> printAllCaps("abc")
// ABC
// >> printAllCaps(null)
// null
```
메소드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.

객체 그래프에서 널이 될 수 있눈 중간 객체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편할 때가 자주 있다.

```kotlin
class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)

class Company(val name: String, val address: Address?)

class Person(val name: String, val company: Company?)

fun Person.countryName(): String {
	val country = this.company?.address?.country
    return if (country != null) country else "Unknown" 
}
```

### 1.4 엘비스 연산자 ?:
null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 엘비스 연산자(?:)를 제공한다.

```kotlin
fun foo(string: String) {
	val t: String = s ?: ""
}
```

위의 사람과 회사, 주소를 표현한 코드에서 countryName 함수도 한줄로 표현할 수 있다.
```kotlin

fun Person.countryName() = company?.address?.country ?: "Unknown"
```

코틀린에서는 return이나 throw 등의 연산도 식이다.

따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.

이런 경우 엘비스 연산자의 좌항이 널이면 함수가 즉시 어떤 값을 반환하거나 예외를 던진다.

이런 패턴의 경우 함수의 전제 조건을 검사하는 경우 특히 유용하다.

### 1.5 안전한 캐스트 as?
as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다. as?는 값을 대상 타입으로 변환할 수 없으면 null을 반환한다.

안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.

### 1.6 널 아님 단언 !!
널 아님 단언은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구다.

널에 대해 !!를 적용하면 NPE가 발생한다.

근본적으로 !!는 컴파일러에게 "나는 이 값이 null이 아님을 잘 알고 있다. 내가 잘못 생각했다면 예외가 발생해도 감수하겠다"라고 말하는 것이다.

!!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.

### 1.7 let 함수
let함수를 사용하면 널이 될 수 있는 식을 더 쉽게 다룰 수 있다.

let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘기는 경우다.

let함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.

let을 쓰면 긴 식의 결과를 저장하는 변수를 따로 만들 필요가 없다.
```kotlin
val person: Person? = getTheBestPersonInTheWorld()
if (person != null) sendEmailTo(person.email)
```
굳이 person 변수를 추가할 필요 없이 다름과 같이 쓸 수 있다.
```kotlin
getTheBestPersonInTheWorld()?.let{ sendEmailTo(it.email) }
```

### 1.8 나중에 초기화할 프로퍼티
객체 인스턴스를 일단 생성한 다음에 나중에 초기화하는 프레임워크가 많다.

하지만 코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메소드 안에서 초기화할 수 없다.

코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다.

이를 위해 프로퍼티를 나중에 초기화 할 수 있다.

lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다.

나중에 초기화하는 프로퍼티는 항상 var여야 한다.

프로퍼티를 초기화하기 전에 프로퍼티에 접근하면 "lateinit property ~ has not been initialized"이라는 예외가 발생한다.

### 1.9 널이 될 수 있는 타입 확장
널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null값을 다루는 강력한 도구로 활용할 수 있다.

어떤 메소드를 호출하기 전에 수식 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신, 직접 변수에 대해 메소드를 호출해도 확장 함수인 메소드가 알아서 널을 처리해준다.

이런 처리는 확장 함수에서만 가능하다.

일반 멤버 호출은 객체 인스턴스를 통해 디스패치되므로 그 인스턴스가 널인지 여부를 검사하지 않는다.

 예를 들어 코틀린 라이브러리에서 String을 확장해 정의된 isEmpty와 isBlank라는 함수를 보자.

isEmpty는 문자열이 빈 문자열인지 검사하고, isBlank는 문자열이 모두 공백문자로 이뤄졌는지 검사한다.

추가로 String? 타입의 수신 객체에 대해 호출할 수 있는 isNullOrEmpty이나 isNullOrBlank 메소드가 있다.

안전한 호출 없이도 널이 될 수 있는 수식 객체 타입에 대해 선언된 확장 함수를 호출가능하다.

함수는 null 값이 들어오는 경우 이를 적절히 처리한다.

isNullOrBlank는 널을 명시적으로 검사해서 널인 경우 true를 반환하고, 널이 아닌 경우 isBlank를 호출한다.

```kotlin
fun String?.isNullOrBlank(): Boolean =
	this == null || this.isBlank() // 두 번째 "this"에는 스마트 캐스트가 적용된다.
```
자바에서는 메소드 안의 this는 그 메소드가 호출된 수신 객체를 가리키므로 항상 널이 아니다.

코틀린에서는 널이 될 수 있는 타입의 확장 함수 안에서는 this가 널이 될 수 있다는 점이 자바와 다르다.:heart_eyes:

따라서, 널이 될 수 있는 타입에 대한 확장을 정의할 때, 안전한 호출 연산인?.을 사용해야 한다.

### 1.10 타입 파라미터의 널 가능성
코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.

널이 될 수 있는 타입을 포함하는 어떤 타입이라도 타입 파라미터를 대신할 수 있다.

따라서 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다.

```kotlin
fun <T> printHashCode(t: T) {
	println(t?.hashCode())
}

printHashCode(null)
// null
```
타입 파라미터 T에 대해 추론한 타입은 널이 될 수 있는 Any?타입이다.

t 파라미터의 타입 이름 T에는 물음표가 붙어있지 않지만 t는 null을 받을 수 있다.

 타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야 한다.

이렇게 널이 될 수 없는 타입 상한을 지정하면 널이 될 수 있는 값을 거부하게 된다.

```kotlin
fun <T: Any> printHashCode(t: T) {
	println(t.hashCode())
}
printHashCode(null) // 컴파일 에러
// Error: Type parameter bound for `T` is not satisfied
```
 타입 파라미터는 널이 될 수 있는 타입을 표시하려면 반드시 물음표를 타입 이름 뒤에 붙여야 한다는 규칙의 유일한 예외다.:pushpin: 
### 1.11 널 가능성과 자바
 자바 코드에도 애노테이션으로 표시된 널 가능성 정보가 있다. 

이런 정보가 코드에 있으면 코틀린도 그 정보를 활용한다.

따라서 자바의 @Nullable Strin은 코틀린 쪽에서 볼 때 String?와 같고, 자바의 @NotNull String은 코틀린쪽에서 볼 때 String과 같다.

코틀린은 여러 널 가능성 애노테이션을 알아본다.

JSR-305 표준(javax.annotation 패키지), 안드로이드(android.support.annotation 패키지), 젯브레인스 도구들이 지원하는 애노테이션(orj.jetbrains.annotations) 등이 코틀린이 이해할 수 있는 널가능성 애노테이션들이다.

이런 널 가능성 애노테이션이 소스코드에 없는 경우는 더 흥미롭다.

그런 경우 자바의 타입은 코틀린의 플랫폼 타입이 된다.


#### 플랫폼 타입
플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.

그 타입을 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다.

이는 자바와 마찬가지로 플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 온전히 여러분에게 있다는 뜻이다.

코틀린은 플랫폼 타입의 값이 널이 될 수 있는 값에 대해 널 안전성 검사를 중복 수행해도 아무 경고도 표시하지 않는다.

자바와 마찬가지로 여러분이 틀렸다면 NPE이 발생한다.

자바 API를 다룰 때는 조심해야 한다. 대부분의 라이브러리는 널 관련 애노테이션을 쓰지 않는다.

따라서 모든 타입을 널이 아닌 것처럼 다루기 쉽지만 그렇게 하면 오류가 발생할 수 있다.

자바 메소드의 문서를 자세히 살펴봐서 그 메소드가 널을 반환할지 알아내고 널을 반환하는 메소드에 대한 널 감사를 추가해야 한다.

> 특히 제네릭을 다룰 때 상황이 더 나빠진다. 
>
> 그렇다고 코틀린에서 Object?처럼 다루면 해단 원소에 접근할 때 마다 널 감사나 안전한 캐스트를 수행해야한다.
> 
> 이는 널 안정성으로 얻는 이익보다 검사에 드는 비용이 훨씬 더 커진다.
 
 코틀린에서 플랫폼 타입을 선언할 수는 없다. 자바 코드에서 가져온 타입만 플랫폼 타입이 된다.

하지만 IDE나 컴파일러 오류 메시지에서는 플랫폼 타입을 볼 수 있다.

#### 상속
코틀링네서 자바 메소드를 오버라이드할 때 그 메소드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야 한다.

자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.

구현 메소드를 다른 코틀린 코드가 호출할 수 있으므로 코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어준다.

설령 파라미터를 메소드 안에서 결코 사용하지 않아도 이런 예외는 피할 수 없다.

## 2. 코틀린의 원시 타입
## 3. 컬렉션과 배열
