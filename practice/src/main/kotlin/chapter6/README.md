# 코틀린 타입 시스템

1. 널 가능성
2. 코틀린 원시 타입
3. 컬렉션과 배열

코틀린의 타입 시스템은 코드의 가독성을 향상시키는 데 도움이 되는 몇 가지 특성을 제공한다.

그 특성으로 널이 될 수 있는 타입과 읽기 전용 컬렉션이 있다.

또한 코틀린은 자바 타입 시스템에서 불필요하거나 문제가 되던 부분을 제거했다.

배열 지원이 그런 예에 속한다.

## 1. 널 가능성

널 가능성은 NPE(NullPointerException)를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다.

코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 이 문제를 가능한 컴파일 시점으로 옮가는 것이다.

널이 될 수 있는지 여부를 타입 시트메에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

### 1.1 널이 될 수 있는 타입

코틀린과 자바의 첫 번째이자 가장 중요한 차이는 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점이다.

어떤 변수가 널이 될 수 있다면 그 변수에 대해(그 변수를 수신 객체로) 메소드를 호출하면 NPE이 발생할 수 있으므로 안전하지 않다.

코틀린은 그런 메소드 호출을 금지함으로써 많은 오류를 방지한다.

```java
int stringLength(String string){
        return string.length()
        }
```

위 메소드는 안전한가? 이 함수에 null을 넘기면 NPE가 발생한다.

```kotlin
fun stringLength(string: String) = string.length
```

코틀린에서는 stringLength함수에 null이거나, null이 될 수 있는 인자를 넘기는 것은 금지되며, 혹시 그런 값을 넘기면 컴파일 시 오류가 발생한다.

따라서, stringLength함수가 결코 실행 시점에 NPE을 발생시키지 않으리라 장담할 수 있다.

이 함수가 널과 문자열을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표를 명시해야한다.

```kotlin
fun stringLength(string: String?) = string.length
// ERROR: only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String>
```

널이 됳 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.

또, 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다

```kotlin
val x: String? = null
val y: String = x
// ERROR: Type mismatch: inferred type is String? but string was expected
```

널 가능성을 다루기 위해 사용할 수 있는 도구가 of 검사뿐이라면 코드가 번잡해지는 일을 피할 수 없을 것이다.

다행히 코틀린은 널이 될 수 있는 값을 다룰 때 도움이 되는 여러 도구를 제공한다.

### 1.2 타입의 의미

위키피디아에서 타입은 "타입은 분류(classification)로 .. 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다."

자바의 타입 시스템은 null이 들어있는 경우에는 사용할 수 있는 연산이 많지 않다.

이는 자바의 타입 시스템이 널을 제대로 다루지 못한다는 뜻이다.

변수에 선언된 타입이 있지만 널 여부를 추가로 검사하기 전에는 그 변수에 대한 어떤 연산을 수행할 수 있을지 알 수 없다.

프로그램을 작성하면서 프로그램의 데이터 흐름속에서 특정 위치에 특정 변수가 절대로 널일 수 없다는 사실을 확인하고 이런 검사를 생략하는 경우가 자주 있다.

하지만 그 생각이 틀리면 실행 시점에서 프로그램이 NPE 예외를 발생시키며 오류로 중단된다.

코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.

널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고,

실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다. 따라서 그런 연산을 아예 금지시킬 수 있다.

> 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.
>
> 모든 검사는 컴파일 시점에 수향된다.
>
> 따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다.

### 1.3 안전한 호출 연산자 ?.

?. 은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.

예를 들어 ```s?.toUpperCase()```는 훨씬 더 복잡한 ```if (s != null) s.toUppserCase() else null ```과 같다

안전한 호출의 결과 타입도 널이 될 수 있는 타입이라는 사실에 위의 하자.

```kotlin
fun printAllCaps(s: String?) {
	val allCaps: String? = s?.toUpperCase()
	println(allCaps)
}

// >> printAllCaps("abc")
// ABC
// >> printAllCaps(null)
// null
```

메소드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.

객체 그래프에서 널이 될 수 있눈 중간 객체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편할 때가 자주 있다.

```kotlin
class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)

class Company(val name: String, val address: Address?)

class Person(val name: String, val company: Company?)

fun Person.countryName(): String {
	val country = this.company?.address?.country
	return if (country != null) country else "Unknown"
}
```

### 1.4 엘비스 연산자 ?:

null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 엘비스 연산자(?:)를 제공한다.

```kotlin
fun foo(string: String) {
	val t: String = s ?: ""
}
```

위의 사람과 회사, 주소를 표현한 코드에서 countryName 함수도 한줄로 표현할 수 있다.

```kotlin

fun Person.countryName() = company?.address?.country ?: "Unknown"
```

코틀린에서는 return이나 throw 등의 연산도 식이다.

따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.

이런 경우 엘비스 연산자의 좌항이 널이면 함수가 즉시 어떤 값을 반환하거나 예외를 던진다.

이런 패턴의 경우 함수의 전제 조건을 검사하는 경우 특히 유용하다.

### 1.5 안전한 캐스트 as?

as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다. as?는 값을 대상 타입으로 변환할 수 없으면 null을 반환한다.

안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.

### 1.6 널 아님 단언 !!

널 아님 단언은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구다.

널에 대해 !!를 적용하면 NPE가 발생한다.

근본적으로 !!는 컴파일러에게 "나는 이 값이 null이 아님을 잘 알고 있다. 내가 잘못 생각했다면 예외가 발생해도 감수하겠다"라고 말하는 것이다.

!!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.

### 1.7 let 함수

let함수를 사용하면 널이 될 수 있는 식을 더 쉽게 다룰 수 있다.

let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘기는 경우다.

let함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.

let을 쓰면 긴 식의 결과를 저장하는 변수를 따로 만들 필요가 없다.

```kotlin
val person: Person? = getTheBestPersonInTheWorld()
if (person != null) sendEmailTo(person.email)
```

굳이 person 변수를 추가할 필요 없이 다름과 같이 쓸 수 있다.

```kotlin
getTheBestPersonInTheWorld()?.let { sendEmailTo(it.email) }
```

### 1.8 나중에 초기화할 프로퍼티

객체 인스턴스를 일단 생성한 다음에 나중에 초기화하는 프레임워크가 많다.

하지만 코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메소드 안에서 초기화할 수 없다.

코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다.

이를 위해 프로퍼티를 나중에 초기화 할 수 있다.

lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다.

나중에 초기화하는 프로퍼티는 항상 var여야 한다.

프로퍼티를 초기화하기 전에 프로퍼티에 접근하면 "lateinit property ~ has not been initialized"이라는 예외가 발생한다.

### 1.9 널이 될 수 있는 타입 확장

널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null값을 다루는 강력한 도구로 활용할 수 있다.

어떤 메소드를 호출하기 전에 수식 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신, 직접 변수에 대해 메소드를 호출해도 확장 함수인 메소드가 알아서 널을 처리해준다.

이런 처리는 확장 함수에서만 가능하다.

일반 멤버 호출은 객체 인스턴스를 통해 디스패치되므로 그 인스턴스가 널인지 여부를 검사하지 않는다.

예를 들어 코틀린 라이브러리에서 String을 확장해 정의된 isEmpty와 isBlank라는 함수를 보자.

isEmpty는 문자열이 빈 문자열인지 검사하고, isBlank는 문자열이 모두 공백문자로 이뤄졌는지 검사한다.

추가로 String? 타입의 수신 객체에 대해 호출할 수 있는 isNullOrEmpty이나 isNullOrBlank 메소드가 있다.

안전한 호출 없이도 널이 될 수 있는 수식 객체 타입에 대해 선언된 확장 함수를 호출가능하다.

함수는 null 값이 들어오는 경우 이를 적절히 처리한다.

isNullOrBlank는 널을 명시적으로 검사해서 널인 경우 true를 반환하고, 널이 아닌 경우 isBlank를 호출한다.

```kotlin
fun String?.isNullOrBlank(): Boolean =
	this == null || this.isBlank() // 두 번째 "this"에는 스마트 캐스트가 적용된다.
```

자바에서는 메소드 안의 this는 그 메소드가 호출된 수신 객체를 가리키므로 항상 널이 아니다.

코틀린에서는 널이 될 수 있는 타입의 확장 함수 안에서는 this가 널이 될 수 있다는 점이 자바와 다르다.:heart_eyes:

따라서, 널이 될 수 있는 타입에 대한 확장을 정의할 때, 안전한 호출 연산인?.을 사용해야 한다.

### 1.10 타입 파라미터의 널 가능성

코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.

널이 될 수 있는 타입을 포함하는 어떤 타입이라도 타입 파라미터를 대신할 수 있다.

따라서 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다.

```kotlin
fun <T> printHashCode(t: T) {
	println(t?.hashCode())
}

printHashCode(null)
// null
```

타입 파라미터 T에 대해 추론한 타입은 널이 될 수 있는 Any?타입이다.

t 파라미터의 타입 이름 T에는 물음표가 붙어있지 않지만 t는 null을 받을 수 있다.

타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야 한다.

이렇게 널이 될 수 없는 타입 상한을 지정하면 널이 될 수 있는 값을 거부하게 된다.

```kotlin
fun <T : Any> printHashCode(t: T) {
	println(t.hashCode())
}
printHashCode(null) // 컴파일 에러
// Error: Type parameter bound for `T` is not satisfied
```

타입 파라미터는 널이 될 수 있는 타입을 표시하려면 반드시 물음표를 타입 이름 뒤에 붙여야 한다는 규칙의 유일한 예외다.:pushpin:

### 1.11 널 가능성과 자바

자바 코드에도 애노테이션으로 표시된 널 가능성 정보가 있다.

이런 정보가 코드에 있으면 코틀린도 그 정보를 활용한다.

따라서 자바의 @Nullable Strin은 코틀린 쪽에서 볼 때 String?와 같고, 자바의 @NotNull String은 코틀린쪽에서 볼 때 String과 같다.

코틀린은 여러 널 가능성 애노테이션을 알아본다.

JSR-305 표준(javax.annotation 패키지), 안드로이드(android.support.annotation 패키지), 젯브레인스 도구들이 지원하는 애노테이션(
orj.jetbrains.annotations) 등이 코틀린이 이해할 수 있는 널가능성 애노테이션들이다.

이런 널 가능성 애노테이션이 소스코드에 없는 경우는 더 흥미롭다.

그런 경우 자바의 타입은 코틀린의 플랫폼 타입이 된다.

#### 플랫폼 타입

플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.

그 타입을 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다.

이는 자바와 마찬가지로 플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 온전히 여러분에게 있다는 뜻이다.

코틀린은 플랫폼 타입의 값이 널이 될 수 있는 값에 대해 널 안전성 검사를 중복 수행해도 아무 경고도 표시하지 않는다.

자바와 마찬가지로 여러분이 틀렸다면 NPE이 발생한다.

자바 API를 다룰 때는 조심해야 한다. 대부분의 라이브러리는 널 관련 애노테이션을 쓰지 않는다.

따라서 모든 타입을 널이 아닌 것처럼 다루기 쉽지만 그렇게 하면 오류가 발생할 수 있다.

자바 메소드의 문서를 자세히 살펴봐서 그 메소드가 널을 반환할지 알아내고 널을 반환하는 메소드에 대한 널 감사를 추가해야 한다.

> 특히 제네릭을 다룰 때 상황이 더 나빠진다.
>
> 그렇다고 코틀린에서 Object?처럼 다루면 해단 원소에 접근할 때 마다 널 감사나 안전한 캐스트를 수행해야한다.
>
> 이는 널 안정성으로 얻는 이익보다 검사에 드는 비용이 훨씬 더 커진다.

코틀린에서 플랫폼 타입을 선언할 수는 없다. 자바 코드에서 가져온 타입만 플랫폼 타입이 된다.

하지만 IDE나 컴파일러 오류 메시지에서는 플랫폼 타입을 볼 수 있다.

#### 상속

코틀링네서 자바 메소드를 오버라이드할 때 그 메소드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야 한다.

자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.

구현 메소드를 다른 코틀린 코드가 호출할 수 있으므로 코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어준다.

설령 파라미터를 메소드 안에서 결코 사용하지 않아도 이런 예외는 피할 수 없다.

## 2. 코틀린의 원시 타입

Int, Boolean, Any 등의 원시 타입에 대해 살펴본다.

코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다.

잠시 후 그 이유와 코틀린 내부에서 어떻게 원시 타입에 대한 래핑이 작동하는지 설명한다.

또한 Object, Void 등의 자바 타입과 코틀린 타입 간의 대응 관계에 대해서도 살펴본다.

### 2.1 원시 타입 Int, Boolean 등

코틀린은 자바처럼 원시 타입과 래퍼 타입을 구분하지 않으므로 항상 같은 타입을 사용한다.

코틀린은 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다.(원시타입인지, 참조 타입인지)

예를 들어, 대부분의 경우(변수, 프로퍼티, 파라미터, 반환 타입 등) 코틀린의 Int 타입은 자바 int 타입으로 컴파일 된다.

이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우뿐이다.

예를 들어 Int 타입을 컬렉션의 타입 파라미터로 넘기면 그 컬렉션에는 Int의 래퍼 타입에 해당하는 java.lang.Integer 객체가 들어간다.

### 2.2 널이 될 수 있는 원시 타입 : Int?, Boolean? 등

null 참조를 자바의 참조 타입의 변수에만ㄴ 대입할 수 있기 때문에 널이 될 수 있는 코틀린 타입은 자바 원시 타입으로 표현할 수 없다.

따라서 코틀린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일된다.

앞에서 이야기한 대로 제네릭 클래스의 경우 래퍼 타입을 사용한다.

어떤 클래스의 타입 인자로 원시 타입을 넘기면 코틀린은 그 타입에 대한 박스 타입을 사용한다.

예를 들어 다음 문장에서 null 값이나 널이 될 수 있는 타입을 전혀 사용하지 않았지만 만들어지는 리스트는 래퍼인 Integer 타입으로 이뤄진 리스트다.

```kotlin
val listOfInts = listOf(1, 2, 3)
```

이렇게 컴파일하는 이유는 자바 가상머신에서 제네릭을 구현하는 방법 때문이다.

JVM은 타입 인자로 원시 타입을 허용하지 않는다.

따라서 자바나 코틀린 모두 제네릭 클래스는 항상 박스 타입을 사용해야 한다.

원시 타입으로 이뤄진 대규모 컬렉션을 효율적으로 저장해야 한다면 원시 타입으로 이뤄진 효율적인 켈렉션을 제공하는 서드파티 라이브러리를 사용하거나

배열을 사용해야 한다.

### 2.3 숫자 변환

코틀린과 자바의 가장 큰 차이점 중 하나는 숫자를 변환하는 방식이다.

코틀린은 한타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다.

결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다.

예를 들어 코틀린 컴파일러는 다음 코드를 거부한다.

```kotlin
val i = 1
val l: Long = i // 컴파일 에러
```

대신 직접 변환 메소드를 호출해야 한다.

```kotlin
val i = 1
val l: Long = i.toLong()
```

코틀린은 모든 원시타입(Boolean은 제외)에 대한 변환 함수를 제공한다. (toByte(), toShort()...)

양방향 변환 함수가 모두 제공된다. (큰 -> 작 데이터 손실!)

코틀린은 자동 형변환을 제공하지 않는다.

```kotlin
val x = 1 //Int 타입
val list = listOf(1L, 2L, 3L)
x in list // >> false
```

코틀린에서는 타입을 명시적으로 변환해서 같은 타입의 값으로 만든 후 비교해야 한다.

```kotlin
val x = 1
println(x.toLong() in listOf(1L, 2L, 3L)) // >> true
```

숫자 리터럴을 사용할 때는 보통 변환 함수를 호출할 필요가 없다.

42L이나 42.0f 처럼 상수 뒤에 타입을 표현하는 문자를 붙이면 변환이 필요 없다.

또한 직접 변환하지 않아도 숫자 리터럴을 타입이 선언된 변수에 대입하거나 함수에게 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 넣어준다.

추가로 산술 연산자는 적당한 타입의 값을 받아들일 수 있게 이미 오버로드돼 있다.

```kotlin
fun foo(l: Long) = println(l)
val b: Byte = 1
val l = b + 1L
foo(42) // 컴파일러는 Long 해석
```

코틀린 산술 연산자에서도 자바와 똑같이 숫자 연산 시 값 넘침이 발생할 수 있다.

코틀린은 값 넘침을 검사하느라 추가 비용을 들이지 않는다.

### 2.4 Any, Any? : 최상위 타입

자바에서 Object가 클래스 계층의 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입이다.

코틀린에서는 Any가 Int 등의 원시 타입을 포함한 모든 타입의 조상 타입이다.

자바와 마찬가지로 코틀린에서도 원시 타입 값을 Any 타입의 변수에 대입하면 자동으로 값을 객체로 감싼다.

```kotlin
val answer: Any = 42
```

코틀린에서 널을 포함하는 모든 값을 대입할 변수를 선언하려면 Any? 타입을 사용해야 한다.

자바 메소드에서 Object를 인자로 받거나 반환하면 코틀린에서는 Any로 그 타입을 취급한다.(널 여부를 알 수 없으므로 플랫폼 타입인 Any!로 취급)

코틀린 함수가 Any를 사용하면 자바 바이트코드의 Object로 컴파일된다.

모든 코틀린 클래스에는 toString, equals, hashCode라는 세 메소드가 들어있다.

이 세 메소드는 Any에 정의된 메소드를 상속한 것이다.

하지만, java.lang.Object에 있는 다른 메소드(wait, notify 등)는 Any에서 사용할 수 없다.

따라서 그런 메소드를 호출하고 싶다면 java.lang.Object 타입으로 값을 캐스트해야 한다.

### 2.5 Unit 타입 : 코틀린의 void

코틀린은 Unit 타입은 자바 void와 같은 기능을 한다.

```kotlin
fun f(): Unit {
	...
}
fun f(): {
	...
}
```

위 두 함수는 같은 함수다.

코틀린 함수의 반환타입이 Unit이고 그 함수가 제네릭 함수를 오버라이드하지 않는다면 그 함수는 내부에서 자바 void함수로 컴파일된다.

그런 코틀린 함수를 자바에서 오버라이드하는 경우 void를 반환타입으로 해야 한다.

그렇다면 코틀린의 Unit이 자밥 void와 다른 점은 무엇일까?

Unit은 모든 기능을 갖는 일반적인 타입이며, void와 달리 Unit을 타입 인자로 쓸 수 있다.

Unit 타입에 속한 값은 단 하나뿐이며, 그 이름도 Unit이다.

Unit타입의 함수는 Unit값을 묵시적으로 반환한다.

이 두 특성은 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit을 쓸 때 유용하다. :heart_eyes:

```kotlin
interface Processor<T> {
	fun process(): T
}

class NoResultProcessor : Processor<Unit> {
	override fun process() {
		TODO("Not yet implemented")
	}
}
```
인터페이스의 시그니처는 process 함수가 어떤 값을 반환하라고 요구한다.

하지만 NoResultProcessor에서 명시적으로 Unit을 반환할 필요는 없다. 컴파일러가 묵시적으로 return Unit을 넣어준다.

함수형 프로그래밍에서 전통적으로 Unit은 '단 하나의 인스턴스만 갖는 타입'을 의미해 왔고 바로 그 유일한 인스턴스의 유무가 자바 void와 코틀린 Unit을 구분하는 가장 큰 차이이다.


### 2.6 Nothing 타입 : 이 함수는 결코 정상적으로 끝나지 않는다.
코틀린에는 결코 성공적으로 값을 돌려주는 일이 없으므로 반환 값이라는 개념 자체가 의미 없는 함수가 일부 존재한다.

예를 들어 테스트 라이브러리들은 fail이라는 함수를 제공하는 경우가 많다.

코틀린에는 Nothing이라는 특별한 반환 타입이 있다.

```kotlin

fun fail(message: String) : Nothing {
	throw IllegalArgumentException(message)
}
```

Nothing 타입은 아무 값도 포함하지 않는다. 따라서 Nothing 은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.

그 외의 다른 용도로 사용하는 경우 Nothing 타입의 변수를 선언하더라도 그 변수에 아무 값도 저장할 수 없으므로 아무 의미도 없다.

 Nothing을 반환하는 함수를 엘비스 연산자의 우항에 사용해서 전제 조건을 검사할 수 있다.

```kotlin
val address = company.address ?: fail("No Address")
```

컴파일러는 Nothing이 반환 타입인 함수가 결코 정상 종료되지 않음을 알고 그 함수를 호출하는 코드를 분석할 때 사용한다.
## 3. 컬렉션과 배열

### 3.1 널 가능성과 컬렉션 
컬렉션 안에 널 값을 넣을 수 있는지 여부는 어떤 변수의 값이 널이 될 수 있는지 여부와 마찬가지로 중요하다.

변수 타입 뒤에 ?를 붙이면 그 변수에 널을 저장할 수 있다는 뜻인 것처럼 타입 인자로 쓰인 타입에도 같은 표시를 사용할 수 있다.

코틀린 1.1부터 파싱에 실패하면 null을 반환하는 String.toIntOrNull을 사용해 내용을 더 줄일 수 있다.

 어떤 변수 타입의 널 가능성과 타입 파라미터로 쓰이는 타입의 널 가능성 사이의 차이를 살펴보자.

첫 번째 경우 리스트 자체는 항상 널이 아니다. 하지만 리스트에 들어있는 각 원소는 널이 될 수도 있다.

두 번째 경우 리스트를 가리키는 변수에는 널이 들어갈 수 있지만 리스트 안에는 널이 아닌 값만 들어간다. 

 경우에 따라 널이 될 수 있는 값으로 이뤄진 널이 될 수 있는 리스트를 정의해야 할 수도 있다.

코틀린에서는 물음표를 2개 사용해 List<Int?>?로 이를 표현한다.

이런 리스트를 처리할 때는 변수에 대해 널 검사를 수행한 다음에 그 리스트에 속한 모든 원소에 대해 다시 널 검사를 수행해야 한다.

널이 될 수 있는 값으로 이뤄진 컬렉션으로 널 값을 걸러내는 경우가 자주 있어서 코틀린 표준 라이브러리는 그런 일을 하는 filterNotNull이라는 함수를 제공한다.

```kotlin
fun addValidNumbers (numbers: List<Int?>) {
  val validNumbers = numbers.filterNotNull()
  println("Sum of valid numbers: ${validNumbers.sum()}")
  println("Invalid numbers: ${numbers.size-validNumbers.size}")
}
```
filterNotNull이 컬렉션 안에 널이 들어있지 않음을 보장해주므로 validNumbers는 List<Int> 타입이다.

### 3.2 읽기 전용과 변경 가능한 컬렉션
코틀린 컬렉션과 자바 컬렉션을 나누는 가장 중요한 특성 하나는 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다는 점이다.

이런 구분은 코틀린 컬렉션을 다룰 때 사용하는 가장 기초적인 인터페이스인 kotlin.collections.Collection부터 시작한다.

이 Collection 인터페이스를 사용하면 컬렉션 안의 원소에 대해 이터레이션하고, 컬렉션의 크기를 얻고, 어떤 값이 컬렉션 안에 들어있는지 검사하고, 컬렉션에서 데이터를 읽는 여러 다른 연산을 수행할 수 있다.

하지만 Collection에는 원소를 추가하거나 제거하는 메소드가 없다.

 컬렉션의 데이터를 수정하려면 kotlin.collections.MutableColletion 인터페이스를 사용하라. MutableCollection은 일반 인터페이스인 kotlin.collections.Collection을 확장하면서 원소를 추가하거나, 삭제하거나, 컬렉션 안의 원소를 모두 지우는 등의 메소드를 더 제공한다.
 
- Collection \<\<interface>>
    -  size
    - iterator()
    - contains()
    
- MutableCollection \<\<interface>>
    - add()
    - remove()
    - clear()
    
코드에서 가능하면 항상 읽기 전용 인터페이스를 사용하는 것을 일반적인 규칙으로 삼아라.

코드가 컬렉션을 변경할 필요가 있을 때만 변경 가능한 버전을 사용하라.

 val과 var의 구별과 마찬가지로 컬렉션의 읽기 전용 인터페이스와 변경 가능 인터페이스를 구별한 이유는 프로그램에서 데이터에 어떤 일이 벌어지는지를 더 쉽게 이해하기 위함이다.
 
컬렉션 인터페이스를 사용할 때 항상 염두에 둬야 할 핵심은 읽기 전용 컬렉션이라고해서 꼭 변경 불가능한 컬렉션일 필요는 없다는 점이다.

읽기 전용 인터페이스 타입인 변수를 사용할 때 그 인터페이스는 실제로는 어떤 컬렉션 인스턴스를 가리키는 수많은 참조 중 하나일 수 있다.

어떤 동일한 컬렉션 객체를 가리키는 읽기 전용 컬렉션 타입의 참조와 변경 가능한 컬렉션 타입의 참조가 있는 경우에서 이 컬렉션을 참조하는

다른 코드를 호출하거나 병렬 실행한다면 컬렉션을 사용하는 도중에 다른 컬렉션이 그 컬렉션의 내용을 변경하는 상황이 생길 수 있고, 이런 상황에서는 ConcurrentModificationException이나 다른 오류가 발생할 수 있다.

따라서 읽기 전용 컬렉션이 항상 스레드 안전하지 않다는 점을 명심해야 한다.

다중 스레드 환경에서 데이터를 다루는 경우 그 데이터를 적절히 동기화하거나 동시 접근을 혀용하는 데이터 구조를 활용해야 한다.

### 3.3 코틀린 컬렉션과 자바
모든 코틀린 컬렉션은 그에 상응하는 자바 컬렉션 인터페이스의 인스턴스라는 점은 사실이다.

따라서 코틀린과 자바 사이를 오갈 때 아무 변환도 필요 없다. 또한 래퍼 클래스를 만들거나 데이터를 복사할 필요도 없다.

하지만 코틀린은 모든 자바 컬렉션 인터페이스마다 읽기 전용 인터페이스와 변경 가능한 인터페이스라는 두 가지 표현을 제공한다.

 코틀린의 읽기 전용과 변경 가능 인터페이스의 기본 구조는 java.util 패키지에 있는 자바 컬렉션 인터페이스의 구조를 구대로 옮겨 놓았다. 
 
변경 가능한 인터페이스는 java.util 패키지에 있는 인터페이스와 직접적으로 연관되지만 읽기 전용 인터페이스에는 컬렉션을 변경할 수 있는 모든 요소가 빠져있다.

이런 방식을 통해 코틀린은 자바 호환성을 제공하는 한편 읽기 전용 인터페이스와 변경가능 인터페이스를 분리한다.


| 컬렉션 타입 | 읽기 전용 타입 | 변경 가능 타입 |
|------|---|---|
| List | listOf | mutableListOf, arrayListOf |
| Set | setOf | mutableSetOf, hashSetOf, linkedSetOf, sortedSetOf |
| Map | mapOf | mutableMapOf, hashMapOf, linkedMapOf, sortedMapOf |

setOf와 mapOf()는 자바 표준 라이브러리에 속한 클래스의 인스턴스를 반환한다. (코틀린 1.1)

미래의 코틀린에서는 setOf나 mapOf가 진정한 불변 컬렉션 인스턴스를 반환하게 바뀔 수도 있다.

 자바 메소드를 호출하되 컬렉션을 인자로 넘겨야 한다면 따로 변환하거나 복사하는 등의 추가 작업 없이 직접 컬렉션을 넘기면 된다.

이런 성질로 인해 컬렉션의 변경 가능성과 관룐햐 중요한 문제가 생긴다.

자바는 읽기 전용 컬렉션과 변경 가능 컬렉션을 구분하지 않으므로, 코틀린에서 읽기 전용 Collection으로 선언된 객체라도 자바 코드에서는 그 컬렉션 객체의 내용을 변경할 수 있다.

코틀린 컴파일러는 자바 코드가 컬렉션에 대해 어떤 일을 하는지 완전히 분석할 수 없다.

따라서 컬렉션을 변경하는 자바 메소드에 읽기 전용 Collection을 넘겨도 코틀린 컴파일러가 이를 막을 수 없다.

```java
public class CollectionUtils {
    public static List<String> uppercaseAll (List<String> items) {
        for (int i = 0; i < items.size(); i++) {
            items.set(i, items.get(i).toUpperCase());
        }
        return items;
    }
}
```

```kotlin
fun printInUppercase(list: List<String>) { // 읽기 전용 파라미터
	println(CollectionUtils.uppercaseAll(list))
    println(list.first())	
}

val list = listOf("a", "b", "c")
printInUppercase(list)
// [A, B, C]
// A
```
따라서 사용자가 컬렉션을 자바로 넘기는 코틀린 프로그램을 작성한다면 호출하려는 자바 코드가 컬렉션을 변경할지 여부에 따라 올바른 파라미터 타입을 사용할 책임은 사용자에게 있다.

 이런 함정은 널이 아닌 원소로 이뤄진 컬렉션 타입에서도 발생한다.
 
널이 아닌 원소로 이뤄진 컬렉션을 자바 메소드로 넘겼는데 자바 메소드가 널을 컬렉션에 넣을 수도 있다.

코틀린에서 이를 금지할 방법이 없고, 성능을 포기하지 않고는 컬렉션에 널 값이 들어왔는지 감지할 방법도 없다.

따라서 컬렉션을 자바 코드에게 넘길 때는 특별히 주의를 기울여야 하며, 코틀린 쪽 타입이 적절히 자바 쪽에서 컬렉션에게 가할 수 있는 변경의 내용을 반영하게 해야 한다.

### 3.4 컬렉션을 플랫폼 타입으로 다루기
널 가능성에서와 같이, 자바 쪽에서 선언한 컬렉션 타입의 변수를 코틀린에서는 플랫폼 타입으로 본다.

플랫폼 타입인 컬렉션은 기본적으로 변경 가능성에 대해 알 수 없다.

따라서 코틀린 코드는 그 타입을 읽기 전용 컬렉션이나 변경 가능한 컬렉션 어느 쪽으로든 다룰 수 있다.

컬렉션 타입이 시그니처에 들어간 자바 메소드 구현을 오버라이드하련는 경우 읽기 전용 컬렉션과 변경 가능 컬렉션의 차이가 문제가 된다.

플랫폼 타입에서 널 가능성을 다룰 때처럼 이런 경우에도 오버라이드하려는 메소드의 자바 컬렉션 타입을 어떤 코틀린 컬렉션 타입으로 표현할지 결정해야 한다.

 이런 상황에서 여러 가지를 선택해야 한다. 그리고 이렇게 선택한 내용을 코틀린에서 사용할 컬렉션 타입에 반영해야 한다.
 
 - 컬렉션이 널이 될 수 있는가?
 - 컬렉션의 원소가 널이 될 수 있는가?
 - 오버라이드하는 메소드가 컬렉션을 변경할 수 있는가?

이런 선택을 제대로 하려면 자바 인터페이스나 클래스가 어떤 맥락에서 사용되는지 정확히 알아야 한다.

보통 자바에서 가져온 컬렉션에 대해 코틀린 구현에서 어떤 작업을 수행해야 할지 검토하면 쉽게 결정을 내릴 수 있다.

### 3.5 객체의 배열과 원시 타입의 배열
```kotlin
fun main(args: Array<String>) {
	for (i in args.indices) {
		println("Argument $i is: ${args[i]}")
    }
}
```
코틀린 배열은 타입 파라미터를 받는 클래스다. 배열의 원소 타입은 바로 그 타입 파라미터에 의해 정해진다.

 코틀린에서 배열을 만드는 방법은 다양하다.

 - arrayOf 함수에 원소를 넘기면 배열을 만들 수 있다.
 - arrayOfNulls 함수에 정수 값을 인자로 넘기면 모든 원소가 null이고 인자로 넘긴 값과 크기가 같은 배열을 만들 수 있다. 물론 원소 타입이 널이 될 수 있는 타입인 경우에만 이 함수를 쓸 수 있다.
 - Array 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열원소를 초기화해준다. arrayOf를 쓰지 않고 각 원소가 널이 아닌 배열을 만들어야 하는 경우 이 생성자를 사용한다.

toTypedArray메소드를 사용하면 쉽게 컬렉션을 배열로 바꿀 수 있다.

```kotlin
val strings = listOf("a", "b", "c")
println("%s/%s/%s".format(*strings.toTypedArray()))
```

다른 제네릭 타입에서처럼 배열 타입의 타입 인자도 항상 객체 타입이 된다.

 코틀린은 원시 타입의 배열을 표현하는 별도 클래스를 각 원시 타입마다 하나씩 제공한다. IntArray, ByteArray,..
 
이 모든 타입은 int[], byte[]... 등으로 컴파일된다.

따라서 그런 배열의 값은 박싱하지 않고 가장 효율적인 방식으로 저장된다.

원시 타입의 배열을 만드는 방법은 다음과 같다.

 - 각 배열 타입의 생성자는 size 인자를 받아서 해당 원시 타입의 디폴트 값으로 초기화된 size 크기의 배열을 반환한다.
 - 팩토리 함수(IntArray를 생성하는 intArrayOf 등)는 여러 값을 가변 인자로 받아서 그런 값이 들어간 배열을 반환한다.
 - (일반 배열과 마찬가지로) 크기와 람다를 인자로 받는 생성자를 사용한다.

```kotlin
val fiveZeros = IntArray(5)
val fiveZerosToo = intArrayOf(0, 0, 0, 0, 0)

val squares = IntArray(5) {i -> (i+1) * (i+1)}
println(squares.joinToString())
 // 1, 4, 9, 16, 25
```

